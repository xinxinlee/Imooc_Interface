import json
"""
Unicode，它为每种语言中的每个字符设定了统一并且唯一的二进制编码。
是一种编码制度，多二进制形式，进行unicode 制度的编码，是有意它不是一种形式，是一种制度
如果人们说unicode 的时候，是说这个串二进制数据，采用的是unicode 制度编码的 UT8-8是unicode的一种形式而已。
所以都是鼓捣二进制数据的，所以涉及到unicode的时候，其实说的是字符串变成二进制的这个过程，跟字符串和语言中类型的转换不是一个层的问题。
字符串是一种数据类型。但是实质也是需要在网络中流转的，所以可以用二进制的形式来表达。
字符串是人类语言和机器语言转换的临界形式，比字典、列表、等等都要高级。数字是天然的可以和计算机语言进行交互的只不过是进制的不同，人类有10进制和16进制，计算机是2进制。
这是网络传输操作，在文件读写方面也是相同的道理，往文件中写的时候，需要把要写入的内容变成字符串才能写进去，读出来的也还是字符串
然后通过各种操作对字符串进行各种操作。
、计算机只能读懂01011010这样的二进制数字形式，一个1或者0是1位叫1bit，同样又认为规定了8个二进制也就是8个bit叫1byte，这1个byte是2个16进制表示。对应的公式是：8bit = 1byte
第一阶段：美国人把人类语言和101010之间做了一个映射关系就是ASCII 码表，其中1byte也就是8bit对应一个字符。ASCII 码表中，字符对应的是二进制的表示方式，所以有255个，在这个阶段里面其实还有一个欧洲扩展的阶段，就是0-127是英语国家可以满足使用，但是欧洲不可以，所以欧洲就扩展了255-128后剩下的127个码位的对应关系。ASCII 也是用2进制进行存储的。
第二阶段：中文和其他亚洲国家为自己国家的文字在ASCII的基础上扩展了编码范围，比如中文就采用了ASCII和gbk的方式来表示一个中文汉字所以是2个字节表示一个中文字，这就是为什么有人会说一个英文是一个字节，一个汉子是2个字节的原因。这是说第二个阶段的一个情况。
第三阶段：每个都根据ASCII 码和自己国家的编码扩展了ascii 码，但是这个码之间不互通。为了统一让大家都认识各自重新规范除了一个unicode规范，就是万国码规范。
unicode是一个字符集，只是展示了字符和数字的对应关系，具体是几进制的几个数字对应什么字符，这种是没有要求的，所以人们就自己编撰了两套对应标准就是UTF-8和utf-16,其中如果没有特殊说明使用的都是utf-16的标准。其中使用2个byte为最小的单位去表示一个字符。所以有2个字节的，有4个字节的，汉字在utf-16编码中要么是2个字节，要么是4个字节。还有一种是接触最多网络传输中使用的utf-8
字符集的，至于是几个字节，看对应的字落在那个范围的模板里,然后是有1byte 2byte 3byte 4个byte 4中模板方式。所以说某个字符到底是几byte是不一定的。
所以网络传输是传输的字节，自己和字符相对应可以通过各种编码和解码函数来实现其中的对应关系。要通过接口发送的话就把字符变成字节，然后接收到熬接口返回的信息就是把字节翻译成字符就行了。
所以经过上述三个阶段的发展，一个汉子是几个字节是不一定的，虽然unicode中多是两个字节表示一个字符。最少是两个字节来表示。所以英文字符为了补齐这个两个字节，就会用0来补位。
对于python2而言，为什么要在开头加一个字符集呢，因为python使用的是ASCII 编码，python诞生时unicode 还没诞生，所以没有使用上。后面的python3 直接使用的就是unicode 编码了。而网络传输中使用的都是UTF-8的形式。
utf-8 每次传送8位数据？？？ UTF-8中，中文需要三个字节3byte。
"""
class Person:
    def __init__(self):
        self.name = "mingming"
        self.age = 18
        self.lists = [4,5,6,"中文字符"]

data = {"dicts": None,"class":None}
dicts = {"name":"mingming","age":21,"lists":[1,2,3,"中文字符"]}
#编码函数
def json_encode():
    #对字典进行编码，会把字典变成字符串
    data_dicts = json.dumps(dicts,indent=4,ensure_ascii=False)#如果此处不加ensure_ascii=False,那这个属性就默认是True,中文在变成字符串后就是\u4e2d\u6587\u5b57\u7b26这样的形式
    #data_dicts = data_dicts.replace('\n', '').replace(' ', '')#由字典编码成字符串后，会有空格和换行等等，可以使用处理字符串的方法对其进行处理
    #print(data_dicts)
    data["dicts"] = data_dicts

    #对类的实例进行编码,会把类的实例初始方法中的属性都转换成字符串
    data_class = json.dumps(Person(),indent=4,default=lambda obj: obj.__dict__)
    #print(data_class)
    data["class"] = data_class
#解码函数
def json_decode():
    #把字符串重新解成字典
    dicts = json.loads(data['dicts'])
    #print(dicts)
    #把字符串解回字典，无法解回到类
    clazz = json.loads(data["class"])
    #print(clazz)

import sys
"""
python的编码和解码学习：
python3中只有字符串有encode()，对象、数字类型、字典、列表等没有这个方法。在调用encode的时候，会把数据转换为byte类型
是一种16进制的表示形式。encode()是一个编码过程，将字符串按照某个字符集编码成16进制的形式，如按照UTF-8进行编码，在解码时
也需要使用UTF-8进行解码把字符串还原。
json 的序列化和反序列化主要是把语言中的类型转化成字符串和把字符串转换成语言中对应的数据类型
sys的encode主要是把字符串根据不同的编码规则转成对应的16进制形式，utf-8 编码是用几个16进制表示的，取决于是用的哪个模板
模板有1byte 2byte 3byte 4byte的。（16进制也是数字形式这样计算机就认识了，可以方便换成可以二进制）
"""
print(sys.getdefaultencoding())#python3 打印文件的默认编码
s = "小明"#默认是unicode编码
s_to_gbk = s.encode('gbk')
b_to_uni = s_to_gbk.decode('gbk')
print(s)
print(s_to_gbk)
print(b_to_uni)
"""
输出：
utf-8
小明
b'\xd0\xa1\xc3\xf7'
小明
"""
